import { MCPTool } from 'mcp-framework';
import { z } from 'zod';

interface GenerateImageInput {
  prompt: string;
  negative_prompt: string;
  seed: number;
  subseed: number;
  subseed_strength: number;
  steps: number;
  width: number;
  height: number;
  pag_scale: number;
}

// Tool: GenerateImageTool
// Description: Esta ferramenta gera imagens a partir de prompts de texto utilizando modelos de IA generativa. Permite customizar parâmetros como prompt negativo, seed, tamanho, passos, etc. Ideal para agentes LLM que precisam criar imagens sob demanda para ilustração, resposta visual ou integração com outros fluxos.
class GenerateImageTool extends MCPTool<GenerateImageInput> {
  name = 'generate-image';
  description = 'Gera imagens a partir de prompts de texto usando modelos de IA generativa.';

  schema = {
    prompt: {
      type: z.string(),
      description: 'Prompt for image generation',
    },
    negative_prompt: {
      type: z.string().optional(),
      description: 'Negative prompt for image generation',
    },
    seed: {
      type: z.number().min(0).optional(),
      description: 'Seed for random number generation',
    },
    subseed: {
      type: z.number().min(0).optional(),
      description: 'Subseed for additional randomness',
    },
    subseed_strength: {
      type: z.number().min(0).optional(),
      description: 'Strength of the subseed',
    },
    steps: {
      type: z.number().min(1).optional(),
      description: 'Number of steps for image generation',
    },
    width: {
      type: z.number().min(1).optional(),
      description: 'Width of the generated image',
    },
    height: {
      type: z.number().min(1).optional(),
      description: 'Height of the generated image',
    },
    pag_scale: {
      type: z.number().min(0).optional(),
    },
  };
  async saveImage(base64Data: string, filename: string): Promise<string> {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');
      const imagesDir = path.join(process.cwd(), 'public', 'images');

      await fs.mkdir(imagesDir, { recursive: true });

      const base64 = base64Data.replace(/^data:image\/(png|jpeg|jpg);base64,/, '');
      const filePath = path.join(imagesDir, filename);
      await fs.writeFile(filePath, Buffer.from(base64, 'base64'));
      return filePath;
    } catch (err: any) {
      return err.message;
    }
  }
  async openAI(input: GenerateImageInput) {
    const { default: OpenAI } = await import('openai');
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

    let prompt = input.prompt;
    if (input.negative_prompt) {
      prompt += `\nNegative prompt: ${input.negative_prompt}`;
    }

    const response = await openai.responses.create({
      model: process.env.GPT_IMAGE_GENERATION_MODEL || 'gpt-5-nano-2025-08-07',
      input: prompt,
      tools: [{ type: 'image_generation' }],
    });

    const imageData = response.output
      .filter((output: any) => output.type === 'image_generation_call')
      .map((output: any) => output.result);

    if (imageData.length > 0) {
      this.saveImage(imageData[0], `${Date.now()}.png`);
      return imageData[0];
    }
    throw new Error('No image generated by OpenAI');
  }
  async local(input: GenerateImageInput) {
    const method = 'POST';
    const headers = new Headers();
    const body = JSON.stringify({
      prompt: input.prompt,
      negative_prompt:
        input.negative_prompt ||
        'low quality, blurry, deformed, bad anatomy, text, watermark',
      seed: input.seed || -1,
      subseed: input.subseed || -1,
      subseed_strength: input.subseed_strength || 0,
      batch_size: 1,
      steps: input.steps || 30,
      width: input.width || 512,
      height: input.height || 512,
      pag_scale: input.pag_scale || 7.5,
    });

    headers.set('Content-Type', 'application/json');

    const response = await fetch(`${process.env.LOCAL_IMAGE_GENERATION_URL}`, {
      method,
      headers,
      body,
    });

    if (!response.ok) {
      throw new Error(`Local API error: ${response.statusText}`);
    }

    const responseData = await response.json();
    this.saveImage(responseData.images[0], `${Date.now()}.png`);
    return responseData.images[0];
  }
  async execute(input: GenerateImageInput) {
    try {
      if (process.env.IMAGE_PROVIDER === 'openai') {
        return await this.openAI(input);
      } else if (process.env.IMAGE_PROVIDER === 'local') {
        return await this.local(input);
      } else {
        throw new Error('Invalid IMAGE_PROVIDER setting');
      }
    } catch (err) {
      if (err instanceof Error) {
        return err.message;
      }
      return String(err);
    }
  }
}

export default GenerateImageTool;
