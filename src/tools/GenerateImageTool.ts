import { MCPTool } from 'mcp-framework';
import { z } from 'zod';

interface GenerateImageInput {
  prompt: string;
  negative_prompt: string;
  seed: number;
  subseed: number;
  subseed_strength: number;
  steps: number;
  width: number;
  height: number;
  pag_scale: number;
}

// Tool: GenerateImageTool
// Description: Esta ferramenta gera imagens a partir de prompts de texto utilizando modelos de IA generativa. Permite customizar parâmetros como prompt negativo, seed, tamanho, passos, etc. Ideal para agentes LLM que precisam criar imagens sob demanda para ilustração, resposta visual ou integração com outros fluxos.
class GenerateImageTool extends MCPTool<GenerateImageInput> {
  name = 'generate-image';
  description = 'Gera imagens a partir de prompts de texto usando modelos de IA generativa.';

  schema = {
    prompt: {
      type: z.string(),
      description: 'Prompt textual detalhado para a geração da imagem. Descreva o que deve aparecer na imagem, estilo, contexto, etc.',
    },
    negative_prompt: {
      type: z.string().optional(),
      description: 'Prompt negativo: elementos, estilos ou características que NÃO devem aparecer na imagem gerada.',
    },
    seed: {
      type: z.number().min(0).optional(),
      description: 'Seed para controle de aleatoriedade. Use para obter resultados reproduzíveis.',
    },
    subseed: {
      type: z.number().min(0).optional(),
      description: 'Subseed para adicionar variação extra à geração da imagem.',
    },
    subseed_strength: {
      type: z.number().min(0).optional(),
      description: 'Intensidade do subseed. Controla o quanto o subseed influencia o resultado.',
    },
    steps: {
      type: z.number().min(1).optional(),
      description: 'Number of steps for image generation',
    },
    width: {
      type: z.number().min(1).optional(),
      description: 'Width of the generated image',
    },
    height: {
      type: z.number().min(1).optional(),
      description: 'Height of the generated image',
    },
    pag_scale: {
      type: z.number().min(0).optional(),
    },
  };
  async saveImage(base64Data: string, filename: string): Promise<string> {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');
      const imagesDir = path.join(process.cwd(), 'public', 'images');

      await fs.mkdir(imagesDir, { recursive: true });

      const base64 = base64Data.replace(/^data:image\/(png|jpeg|jpg);base64,/, '');
      const filePath = path.join(imagesDir, filename);
      await fs.writeFile(filePath, Buffer.from(base64, 'base64'));
      return filePath;
    } catch (err: any) {
      return err.message;
    }
  }
  async openAI(input: GenerateImageInput): Promise<{ success: boolean; image?: string; message?: string }> {
    const { default: OpenAI } = await import('openai');
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

    let prompt = input.prompt;
    if (input.negative_prompt) {
      prompt += `\nNegative prompt: ${input.negative_prompt}`;
    }

    const response = await openai.responses.create({
      model: process.env.GPT_IMAGE_GENERATION_MODEL || 'gpt-5-nano-2025-08-07',
      input: prompt,
      tools: [{ type: 'image_generation' }],
    });

    const imageData = response.output
      .filter((output: any) => output.type === 'image_generation_call')
      .map((output: any) => output.result);

    if (imageData.length > 0) {
      this.saveImage(imageData[0], `${Date.now()}.png`);
      return { success: true, image: imageData[0] };
    }
    return { success: false, message: 'No image generated by OpenAI' };
  }
  async local(input: GenerateImageInput): Promise<{ success: boolean; image?: string; message?: string }> {
    const method = 'POST';
    const headers = new Headers();
    const body = JSON.stringify({
      prompt: input.prompt,
      negative_prompt:
        input.negative_prompt ||
        'low quality, blurry, deformed, bad anatomy, text, watermark',
      seed: input.seed || -1,
      subseed: input.subseed || -1,
      subseed_strength: input.subseed_strength || 0,
      batch_size: 1,
      steps: input.steps || 30,
      width: input.width || 512,
      height: input.height || 512,
      pag_scale: input.pag_scale || 7.5,
    });

    headers.set('Content-Type', 'application/json');

    const response = await fetch(`${process.env.LOCAL_IMAGE_GENERATION_URL}`, {
      method,
      headers,
      body,
    });

    if (!response.ok) {
      return { success: false, message: `Local API error: ${response.statusText}` };
    }

    const responseData = await response.json();
    if (responseData.images && responseData.images[0]) {
      this.saveImage(responseData.images[0], `${Date.now()}.png`);
      return { success: true, image: responseData.images[0] };
    }
    return { success: false, message: 'No image generated by local API' };
  }
  async execute(input: GenerateImageInput): Promise<{ success: boolean; image?: string; message?: string }> {
    try {
      if (process.env.IMAGE_PROVIDER === 'openai') {
        return await this.openAI(input);
      } else if (process.env.IMAGE_PROVIDER === 'local') {
        return await this.local(input);
      } else {
        return { success: false, message: 'Invalid IMAGE_PROVIDER setting' };
      }
    } catch (err) {
      if (err instanceof Error) {
        return { success: false, message: err.message };
      }
      return { success: false, message: String(err) };
    }
  }
}

export default GenerateImageTool;
